<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" href="style.css">
	<link rel="stylesheet" type="text/css" href="nav.css">
	<link rel="stylesheet" type="text/css" href="footer.css">
	<title></title>
</head>
<body>
	<nav>
		<div class="logo">
			<img src="./assets/logo.png">
		</div>
		<ul class="navigation">
			<li><a href="#">Home</a></li>
			<li><a href="#" class="dropdown">About Us <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down-icon lucide-chevron-down"><path d="m6 9 6 6 6-6"/></svg></span></a></li>
			<li><a href="#" class="dropdown">Our Products <span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down-icon lucide-chevron-down"><path d="m6 9 6 6 6-6"/></svg></span></a></li>
			<li><a href="#" class="dropdown">Our Brands<span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-chevron-down-icon lucide-chevron-down"><path d="m6 9 6 6 6-6"/></svg></span></a></li>
			<li><a href="#">Our Gallery</a></li>
			<li><a href="#">Become a Distributor</a></li>
			<li><a href="#">Blog</a></li>
			<li><a href="#">Contact Us</a></li>
		</ul>
		<div class="action_buttons">
			<button class="search"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-search-icon lucide-search"><path d="m21 21-4.34-4.34"/><circle cx="11" cy="11" r="8"/></svg></button>
			<button class="whatsapp"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-message-circle-icon lucide-message-circle"><path d="M2.992 16.342a2 2 0 0 1 .094 1.167l-1.065 3.29a1 1 0 0 0 1.236 1.168l3.413-.998a2 2 0 0 1 1.099.092 10 10 0 1 0-4.777-4.719"/></svg></button>
		</div>
	</nav>


	<!-- Hero Section with Background -->
	<section id="hero-section" style="position: relative; height: 100vh; overflow: hidden;">
		<div id="heroBgContainer" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1;"></div>
	</section>


	<div id="features-slider" class="features-slider"></div>



  <div class="main-display-area" style="position: relative;">
    <div id="animationBgContainer" class="background-canvas-holder" style="position: sticky; top: 0; left: 0; width: 100%; height: 100vh; z-index: 1;"></div>
    <div id="animation-container-main" style="position: relative; z-index: 2;"></div>
</div>



	<footer>
		<div class="top">
			<div class="logo">
				<img src="./assets/logo.png">
			</div>
			<div class="footer-info">
				Twin Tech India Pvt. Ltd. is a leading manufacturer of high-quality Industrial aerosol sprays, car care products, self-adhesive tapes and home care products for various industries worldwide.
			</div>
		</div>
		<div class="line"></div>
		<div class="mid">
			<div class="footer-navs">
			<ul class="nav-1">
				<h3>Quick Links</h3>
				<li><a href="#"><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right-icon lucide-arrow-right"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg></span>Home</a></li>
				<li><a href="#"><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right-icon lucide-arrow-right"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg></span>About Us</a></li>
				<li><a href="#"><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right-icon lucide-arrow-right"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg></span>Our Clients</a></li>
				<li><a href="#"><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right-icon lucide-arrow-right"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg></span>Contact</a></li>
			</ul>
			<ul class="nav-2">
				<h3>Brands</h3>
				<li><a href="#"><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right-icon lucide-arrow-right"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg></span>Evershine</a></li>
				<li><a href="#"><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right-icon lucide-arrow-right"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg></span>SprayZet</a></li>
				<li><a href="#"><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right-icon lucide-arrow-right"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg></span>Twin Tapes</a></li>
				<li><a href="#"><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right-icon lucide-arrow-right"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg></span>Silox</a></li>
				<li><a href="#"><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-right-icon lucide-arrow-right"><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></svg></span>Twinzy</a></li>
			</ul>
			<ul class="nav-3">
				<h3>Download Catalog</h3>
				<li><a href="#"><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-down-to-line-icon lucide-arrow-down-to-line"><path d="M12 17V3"/><path d="m6 11 6 6 6-6"/><path d="M19 21H5"/></svg></span>Everhine</a></li>
				<li><a href="#"><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-down-to-line-icon lucide-arrow-down-to-line"><path d="M12 17V3"/><path d="m6 11 6 6 6-6"/><path d="M19 21H5"/></svg></span>SprayZet</a></li>
				<li><a href="#"><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-arrow-down-to-line-icon lucide-arrow-down-to-line"><path d="M12 17V3"/><path d="m6 11 6 6 6-6"/><path d="M19 21H5"/></svg></span>Twin Tapes</a></li>
			</ul>
			<ul class="nav-4">
				<h3>Get In Touch</h3>
				<li><a href="#"><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mail-icon lucide-mail"><path d="m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7"/><rect x="2" y="4" width="20" height="16" rx="2"/></svg></span>twin@twinindia.com</a></li>
				<li><a href="#"><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-mail-icon lucide-mail"><path d="m22 7-8.991 5.727a2 2 0 0 1-2.009 0L2 7"/><rect x="2" y="4" width="20" height="16" rx="2"/></svg></span>sales@twinindia.com</a></li>
				<li><a href="#"><span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-phone-icon lucide-phone"><path d="M13.832 16.568a1 1 0 0 0 1.213-.303l.355-.465A2 2 0 0 1 17 15h3a2 2 0 0 1 2 2v3a2 2 0 0 1-2 2A18 18 0 0 1 2 4a2 2 0 0 1 2-2h3a2 2 0 0 1 2 2v3a2 2 0 0 1-.8 1.6l-.468.351a1 1 0 0 0-.292 1.233 14 14 0 0 0 6.392 6.384"/></svg></span>91-9310052702</a></li>
			</ul>
		</div>
			<ul class="address">
				<li><a href="#">Office Address : A-304, Solitairian City Center, Knowledge Park III, Greater NOIDA (UP), India 201308</a></li>
				<li><a href="#">Work Address : R-51, 52 & 53, UPSIDC, Sikandrabad -203205 Uttar Pradesh</a></li>
				<ul class="socials">
					<li><a href="#"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-instagram-icon lucide-instagram"><rect width="20" height="20" x="2" y="2" rx="5" ry="5"/><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"/><line x1="17.5" x2="17.51" y1="6.5" y2="6.5"/></svg></a></li>
					<li><a href="#"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-linkedin-icon lucide-linkedin"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"/><rect width="4" height="12" x="2" y="9"/><circle cx="4" cy="4" r="2"/></svg></a></li>
					<li><a href="#"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-youtube-icon lucide-youtube"><path d="M2.5 17a24.12 24.12 0 0 1 0-10 2 2 0 0 1 1.4-1.4 49.56 49.56 0 0 1 16.2 0A2 2 0 0 1 21.5 7a24.12 24.12 0 0 1 0 10 2 2 0 0 1-1.4 1.4 49.55 49.55 0 0 1-16.2 0A2 2 0 0 1 2.5 17"/><path d="m10 15 5-3-5-3z"/></svg></a></li>
					<li><a href="#"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="lucide lucide-facebook-icon lucide-facebook"><path d="M18 2h-3a5 5 0 0 0-5 5v3H7v4h3v8h4v-8h3l1-4h-4V7a1 1 0 0 1 1-1h3z"/></svg></a></li>
				</ul>
			</ul>
		</div>
		<div class="line"></div>
		<div class="bottom">
			<span>Â©Copyright 2026. All Rights Reserved.</span>
		</div>
	</footer>






    <script src="https://unpkg.com/splitting/dist/splitting.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/ScrollTrigger.min.js"></script>
<script>
    gsap.registerPlugin(ScrollTrigger);

    // Same helper as your code
    const wrapElements = (elems, wrapType, wrapClass) => {
      elems.forEach(char => {
        // Prevent double-wrapping if init runs more than once
        if (char.parentElement && char.parentElement.classList.contains(wrapClass)) return;
        const wrapEl = document.createElement(wrapType);
        wrapEl.classList = wrapClass;
        char.parentNode.appendChild(wrapEl);
        wrapEl.appendChild(char);
      });
    };

    const SKIP_TAGS = new Set(['SCRIPT', 'STYLE', 'NOSCRIPT', 'TEMPLATE']);

    const hasDirectText = (el) => {
      for (const node of el.childNodes) {
        if (node.nodeType === Node.TEXT_NODE && node.textContent.trim().length) return true;
      }
      return false;
    };

    // Collect text elements under a .animate-text scope.
    // Rule: pick the first element in a branch that has direct (non-whitespace) text,
    // and skip its descendants to avoid double-splitting nested text.
    const collectTextTargets = (scopeEl) => {
      const targets = [];
      const stack = [...scopeEl.children];

      // Backward-compat: if .animate-text is applied directly to a text element.
      if (hasDirectText(scopeEl) && !scopeEl.dataset.animateTextProcessed && !SKIP_TAGS.has(scopeEl.tagName)) {
        targets.push(scopeEl);
        return targets;
      }

      while (stack.length) {
        const el = stack.shift();
        if (!(el instanceof HTMLElement)) continue;
        if (SKIP_TAGS.has(el.tagName)) continue;
        if (el.dataset.animateTextProcessed) continue;

        if (hasDirectText(el)) {
          targets.push(el);
          continue;
        }

        stack.unshift(...el.children);
      }

      return targets;
    };

    const animateScopes = [...document.querySelectorAll('.animate-text')];

    // Gather all targets across all scopes, then run splitting/GSAP once.
    const targetsToAnimate = animateScopes.flatMap(collectTextTargets);

    // Mark targets so re-running init won't duplicate work.
    targetsToAnimate.forEach(el => {
      el.dataset.animateTextProcessed = '1';
      el.setAttribute('data-splitting', '');
    });

    // Prefer targeted splitting; fall back to global if needed.
    if (targetsToAnimate.length) {
      try {
        Splitting({ target: targetsToAnimate });
      } catch {
        Splitting();
      }
    }

    targetsToAnimate.forEach(el => {
      const allChars = el.querySelectorAll('.char');
      if (!allChars.length) return;

      const tl = gsap.timeline({
        scrollTrigger: {
          trigger: el,
          start: 'top bottom',
          end: 'top top+=10%',
          toggleActions: 'play resume resume reset'
        }
      });

      // If Splitting created word wrappers, animate each word's letters in parallel.
      // (Letters within a word still stagger.)
      const words = [...el.querySelectorAll('.word')];
      if (words.length) {
        words.forEach(word => {
          const chars = word.querySelectorAll('.char');
          if (!chars.length) return;
          wrapElements(chars, 'span', 'char-wrap');
          tl.fromTo(chars,
            {
              willChange: 'transform',
              transformOrigin: '0% 50%',
              xPercent: 105
            },
            {
              duration: 1,
              ease: 'expo',
              xPercent: 0,
              stagger: 0.042
            },
            0
          );
        });
        return;
      }

      // Fallback: animate all characters as one sequence.
      wrapElements(allChars, 'span', 'char-wrap');
      tl.fromTo(allChars,
        {
          willChange: 'transform',
          transformOrigin: '0% 50%',
          xPercent: 105
        },
        {
          duration: 1,
          ease: 'expo',
          xPercent: 0,
          stagger: 0.042
        },
        0
      );
    });

    // If fonts/content shift layout, refresh ScrollTrigger:
    requestAnimationFrame(() => ScrollTrigger.refresh());
  </script>




<script>
      /*
  Infinite Gradient 3D Carousel
  A smooth, infinite-scrolling 3D carousel with dynamic gradient backgrounds
  that change based on the active card's colors.
*/

// ============================================================================
// CONFIGURATION
// ============================================================================

const IMAGES = [
  'https://twinindia.com/wp-content/uploads/2026/01/Screenshot-2026-01-04-003630.png',
  'https://twinindia.com/wp-content/uploads/2026/01/Screenshot-2026-01-04-003640.png',
  'https://twinindia.com/wp-content/uploads/2026/01/Screenshot-2026-01-04-003650.png',
  'https://twinindia.com/wp-content/uploads/2026/01/Screenshot-2026-01-04-003655.png',
];

// Physics constants
const FRICTION = 0.9;           // Velocity decay (0-1, lower = more friction)
const WHEEL_SENS = 0.6;         // Mouse wheel sensitivity
const DRAG_SENS = 1.0;          // Drag sensitivity

// Visual constants
const MAX_ROTATION = 28;        // Maximum card rotation in degrees
const MAX_DEPTH = 140;          // Maximum Z-axis depth in pixels
const MIN_SCALE = 0.92;         // Minimum card scale
const SCALE_RANGE = 0.1;        // Scale variation range
const GAP = 28;                 // Gap between cards in pixels

// ============================================================================
// DOM REFERENCES
// ============================================================================

const stage = document.getElementById("features-slider");

function ensureSliderChildren(root) {
  if (!root) return { cardsRoot: null };

  const existingBg = root.querySelector('#bg');
  if (existingBg) existingBg.remove();

  let cardsRoot = root.querySelector('#cards');
  if (!cardsRoot) {
    cardsRoot = document.createElement('section');
    cardsRoot.id = 'cards';
    cardsRoot.className = 'cards';
    cardsRoot.setAttribute('aria-label', 'Infinite carousel of images');
    root.appendChild(cardsRoot);
  }

  return { cardsRoot };
}

const { cardsRoot } = ensureSliderChildren(stage);
const loader = document.getElementById('loader');

// ============================================================================
// STATE MANAGEMENT
// ============================================================================

// Carousel state
let items = [];                 // Array of {el: HTMLElement, x: number}
let positions = [];             // Float32Array for wrapped positions
let activeIndex = -1;           // Currently centered card index
let isEntering = true;          // Prevents interaction during entry animation

// Layout measurements
let CARD_W = 300;               // Card width (measured dynamically)
let CARD_H = 400;               // Card height (measured dynamically)
let STEP = CARD_W + GAP;        // Distance between card centers
let TRACK = 0;                  // Total carousel track length
let SCROLL_X = 0;               // Current scroll position
let VW_HALF = window.innerWidth * 0.5;

// Physics state
let vX = 0;                     // Velocity in X direction

// Animation frame IDs
let rafId = null;               // Carousel animation frame
let lastTime = 0;               // Last frame timestamp

// Autoplay state
let autoTimer = null;
let autoTween = null;
let lastUserInput = 0;

// Snap state
let snapPending = false;

// Snap tuning: when |vX| falls below this, we snap to the active card.
const SNAP_VELOCITY = 80;
const SNAP_IDLE_MS = 140;

// ============================================================================
// UTILITY FUNCTIONS
// ============================================================================

/**
 * Safe modulo operation that handles negative numbers correctly
 * @param {number} n - The dividend
 * @param {number} m - The divisor
 * @returns {number} The positive remainder
 */
function mod(n, m) {
  return ((n % m) + m) % m;
}

// ============================================================================
// IMAGE PRELOADING
// ============================================================================

/**
 * Preload images using link tags for browser optimization
 * @param {string[]} srcs - Array of image URLs
 */
function preloadImageLinks(srcs) {
  if (!document.head) return;
  
  srcs.forEach((href) => {
    const link = document.createElement('link');
    link.rel = 'preload';
    link.as = 'image';
    link.href = href;
    link.fetchPriority = 'high';
    document.head.appendChild(link);
  });
}

/**
 * Wait for all card images to finish loading
 * @returns {Promise<void>}
 */
function waitForImages() {
  const promises = items.map((it) => {
    const img = it.el.querySelector('img');
    if (!img || img.complete) return Promise.resolve();

    return new Promise((resolve) => {
      const done = () => resolve();
      img.addEventListener('load', done, { once: true });
      img.addEventListener('error', done, { once: true });
    });
  });

  return Promise.all(promises);
}

/**
 * Decode all images to prevent jank during first interaction
 * @returns {Promise<void>}
 */
async function decodeAllImages() {
  const tasks = items.map((it) => {
    const img = it.el.querySelector('img');
    if (!img) return Promise.resolve();

    if (typeof img.decode === 'function') {
      return img.decode().catch(() => {});
    }

    return Promise.resolve();
  });

  await Promise.allSettled(tasks);
}

// ============================================================================
// CAROUSEL SETUP
// ============================================================================

/**
 * Create card DOM elements from image array
 */
function createCards(minCount = IMAGES.length) {
  if (!cardsRoot) return;
  cardsRoot.innerHTML = '';
  items = [];

  const fragment = document.createDocumentFragment();

  const count = Math.max(IMAGES.length, Math.floor(minCount));
  const sources = Array.from({ length: count }, (_, i) => IMAGES[i % IMAGES.length]);

  sources.forEach((src, i) => {
    const card = document.createElement('article');
    card.className = 'card';
    card.style.willChange = 'transform'; // Force GPU compositing

    const img = new Image();
    img.className = 'card__img';
    img.decoding = 'async';
    img.loading = 'eager';
    img.fetchPriority = 'high';
    img.draggable = false;
    img.src = src;

    card.appendChild(img);
    fragment.appendChild(card);
    items.push({ el: card, x: i * STEP });
  });

  cardsRoot.appendChild(fragment);
}

/**
 * Measure card dimensions and calculate layout
 */
function measure() {
  const sample = items[0]?.el;
  if (!sample) return;

  const r = sample.getBoundingClientRect();
  CARD_W = r.width || CARD_W;
  CARD_H = r.height || CARD_H;
  STEP = CARD_W + GAP;
  TRACK = items.length * STEP;

  // Set initial positions
  items.forEach((it, i) => {
    it.x = i * STEP;
  });

  positions = new Float32Array(items.length);
}

// ============================================================================
// TRANSFORM CALCULATIONS
// ============================================================================

function computeTransformComponents(screenX) {
  const norm = Math.max(-1, Math.min(1, screenX / VW_HALF));
  const absNorm = Math.abs(norm);
  const invNorm = 1 - absNorm;

  const ry = -norm * MAX_ROTATION;
  const tz = invNorm * MAX_DEPTH;
  const scale = MIN_SCALE + invNorm * SCALE_RANGE;

  return { norm, absNorm, invNorm, ry, tz, scale };
}


/**
 * Calculate 3D transform for a card based on its screen position
 * @param {number} screenX - Card's X position relative to viewport center
 * @returns {{transform: string, z: number}} Transform string and Z-depth
 */
function transformForScreenX(screenX) {
  const { ry, tz, scale } = computeTransformComponents(screenX);

  return {
    transform: `translate3d(${screenX}px,-50%,${tz}px) rotateY(${ry}deg) scale(${scale})`,
    z: tz,
  };
}

/**
 * Update all card transforms based on current scroll position
 */
function updateCarouselTransforms() {
  const half = TRACK / 2;
  let closestIdx = -1;
  let closestDist = Infinity;

  // Calculate wrapped positions for infinite scroll
  for (let i = 0; i < items.length; i++) {
    let pos = items[i].x - SCROLL_X;
    
    // Wrap position to nearest equivalent position
    if (pos < -half) pos += TRACK;
    if (pos > half) pos -= TRACK;
    
    positions[i] = pos;

    // Track closest card to center
    const dist = Math.abs(pos);
    if (dist < closestDist) {
      closestDist = dist;
      closestIdx = i;
    }
  }

  // Get adjacent cards for selective blur
  const prevIdx = (closestIdx - 1 + items.length) % items.length;
  const nextIdx = (closestIdx + 1) % items.length;

  // Apply transforms to all cards
  for (let i = 0; i < items.length; i++) {
    const it = items[i];
    const pos = positions[i];
    const norm = Math.max(-1, Math.min(1, pos / VW_HALF));
    const { transform, z } = transformForScreenX(pos);

    it.el.style.transform = transform;
    it.el.style.zIndex = String(1000 + Math.round(z)); // Higher z-index for cards in front

    // Apply subtle blur to non-core cards
    const isCore = i === closestIdx || i === prevIdx || i === nextIdx;
    const blur = isCore ? 0 : 2 * Math.pow(Math.abs(norm), 1.1);
    it.el.style.filter = `blur(${blur.toFixed(2)}px)`;
  }

  // Update gradient if active card changed
  if (closestIdx !== activeIndex) {
    activeIndex = closestIdx;
  }
}

// ============================================================================
// ANIMATION LOOP
// ============================================================================

/**
 * Main animation loop for carousel movement
 * @param {number} t - Current timestamp
 */
function tick(t) {
  const dt = lastTime ? (t - lastTime) / 1000 : 0;
  lastTime = t;

  // Apply velocity to scroll position
  SCROLL_X = mod(SCROLL_X + vX * dt, TRACK);

  // Apply friction to velocity
  const decay = Math.pow(FRICTION, dt * 60);
  vX *= decay;
  if (Math.abs(vX) < 0.02) vX = 0;

  // Snap only after the user stops interacting and velocity slows down.
  if (
    snapPending &&
    !isEntering &&
    !autoTween &&
    (!stage || !stage.classList.contains('dragging')) &&
    performance.now() - lastUserInput > SNAP_IDLE_MS &&
    Math.abs(vX) <= SNAP_VELOCITY
  ) {
    snapPending = false;
    snapToActive();
  }

  updateCarouselTransforms();
  rafId = requestAnimationFrame(tick);
}

/**
 * Start the carousel animation loop
 */
function startCarousel() {
  cancelCarousel();
  lastTime = 0;
  rafId = requestAnimationFrame((t) => {
    updateCarouselTransforms();
    tick(t);
  });
}

/**
 * Stop the carousel animation loop
 */
function cancelCarousel() {
  if (rafId) cancelAnimationFrame(rafId);
  rafId = null;
}

// ============================================================================
// AUTOPLAY
// ============================================================================

function signedDeltaToTarget(current, target, track) {
  if (!track) return 0;
  let d = (target - current) % track;
  d = (d + track) % track;
  if (d > track / 2) d -= track;
  return d;
}

function animateToIndex(idx) {
  if (!items.length || !TRACK) return;

  const clamped = mod(idx, items.length);
  const targetX = items[clamped].x;
  const delta = signedDeltaToTarget(SCROLL_X, targetX, TRACK);
  const targetScroll = SCROLL_X + delta;

  vX = 0;
  if (autoTween && typeof autoTween.kill === 'function') autoTween.kill();

  if (window.gsap) {
    const state = { x: SCROLL_X };
    autoTween = window.gsap.to(state, {
      x: targetScroll,
      duration: 0.8,
      ease: 'power2.inOut',
      onUpdate: () => {
        SCROLL_X = mod(state.x, TRACK);
        updateCarouselTransforms();
      },
      onComplete: () => {
        SCROLL_X = mod(state.x, TRACK);
      },
    });
  } else {
    SCROLL_X = mod(targetScroll, TRACK);
    updateCarouselTransforms();
  }
}

function snapToActive() {
  if (isEntering) return;
  if (!items.length || !TRACK) return;

  updateCarouselTransforms();
  if (activeIndex < 0) return;

  vX = 0;
  animateToIndex(activeIndex);
}

function stopAutoAdvance() {
  if (autoTimer) clearInterval(autoTimer);
  autoTimer = null;
  if (autoTween && typeof autoTween.kill === 'function') autoTween.kill();
  autoTween = null;
}

function startAutoAdvance() {
  stopAutoAdvance();
  autoTimer = setInterval(() => {
    if (document.hidden) return;
    if (isEntering) return;
    if (!items.length || !TRACK) return;
    if (stage && stage.classList.contains('dragging')) return;
    if (performance.now() - lastUserInput < 900) return;

    const next = mod((activeIndex < 0 ? 0 : activeIndex) + 1, items.length);
    animateToIndex(next);
  }, 5000);
}

// ============================================================================
// EVENT HANDLERS
// ============================================================================

/**
 * Handle window resize
 */
function onResize() {
  const prevStep = STEP || 1;
  const ratio = SCROLL_X / (items.length * prevStep);
  measure();
  VW_HALF = window.innerWidth * 0.5;
  SCROLL_X = mod(ratio * TRACK, TRACK);
  updateCarouselTransforms();
}

if (stage) {
  // Prevent default drag behavior
  stage.addEventListener('dragstart', (e) => e.preventDefault());

  // Drag state
  let dragging = false;
  let lastX = 0;
  let lastT = 0;
  let lastDelta = 0;

  // Pointer down - start dragging
  stage.addEventListener('pointerdown', (e) => {
    if (isEntering) return;
    if (e.target.closest('.frame')) return;

    lastUserInput = performance.now();
    dragging = true;
    lastX = e.clientX;
    lastT = performance.now();
    lastDelta = 0;
    stage.setPointerCapture(e.pointerId);
    stage.classList.add('dragging');
  });

  // Pointer move - update scroll position
  stage.addEventListener('pointermove', (e) => {
    if (!dragging) return;

    lastUserInput = performance.now();

    const now = performance.now();
    const dx = e.clientX - lastX;
    const dt = Math.max(1, now - lastT) / 1000;

    SCROLL_X = mod(SCROLL_X - dx * DRAG_SENS, TRACK);
    lastDelta = dx / dt; // Track velocity for momentum
    lastX = e.clientX;
    lastT = now;
  });

  // Pointer up - apply momentum
  stage.addEventListener('pointerup', (e) => {
    if (!dragging) return;

    lastUserInput = performance.now();
    dragging = false;
    stage.releasePointerCapture(e.pointerId);
    vX = -lastDelta * DRAG_SENS;
    snapPending = true;
    stage.classList.remove('dragging');
  });
}

// Debounced resize handler
window.addEventListener('resize', () => {
  clearTimeout(onResize._t);
  onResize._t = setTimeout(onResize, 80);
});

// Pause animations when tab is hidden
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    cancelCarousel();
    stopAutoAdvance();
  } else {
    startCarousel();
    startAutoAdvance();
  }
});

// ============================================================================
// INITIALIZATION & ENTRY ANIMATION
// ============================================================================

/**
 * Animate visible cards entering the scene
 * @param {Array} visibleCards - Cards to animate
 */
async function animateEntry(visibleCards) {
  await new Promise((r) => requestAnimationFrame(r));

  const tl = window.gsap.timeline();

  visibleCards.forEach(({ item, screenX }, idx) => {
    const state = { p: 0 }; // 0 -> 1
    const { ry, tz, scale: baseScale } = computeTransformComponents(screenX);

    const START_SCALE = 0.92;
    const START_Y = 40;

    item.el.style.opacity = '0';
    item.el.style.transform =
      `translate3d(${screenX}px,-50%,${tz}px) ` +
      `rotateY(${ry}deg) ` +
      `scale(${START_SCALE}) ` +
      `translateY(${START_Y}px)`;

    tl.to(
      state,
      {
        p: 1,
        duration: 0.6,
        ease: 'power3.out',
        onUpdate: () => {
          const t = state.p;

          const currentScale = START_SCALE + (baseScale - START_SCALE) * t;
          const currentY = START_Y * (1 - t);
          const opacity = t;

          item.el.style.opacity = opacity.toFixed(3);

          if (t >= 0.999) {
            const { transform } = transformForScreenX(screenX);
            item.el.style.transform = transform;
          } else {
            item.el.style.transform =
              `translate3d(${screenX}px,-50%,${tz}px) ` +
              `rotateY(${ry}deg) ` +
              `scale(${currentScale}) ` +
              `translateY(${currentY}px)`;
          }
        },
      },
      idx * 0.05
    );
  });

  await new Promise((resolve) => {
    tl.eventCallback('onComplete', resolve);
  });
}


/**
 * Pre-composite all card positions to prevent first-interaction jank
 */
async function warmupCompositing() {
  const originalScrollX = SCROLL_X;
  const stepSize = STEP * 0.5;
  const numSteps = Math.ceil(TRACK / stepSize);

  // Scroll through entire carousel to force GPU compositing
  for (let i = 0; i < numSteps; i++) {
    SCROLL_X = mod(originalScrollX + i * stepSize, TRACK);
    updateCarouselTransforms();

    // Force paint every few steps (optimization)
    if (i % 3 === 0) {
      await new Promise((r) => requestAnimationFrame(r));
    }
  }

  // Return to original position
  SCROLL_X = originalScrollX;
  updateCarouselTransforms();
  await new Promise((r) => requestAnimationFrame(r));
  await new Promise((r) => requestAnimationFrame(r));
}

/**
 * Initialize the carousel application
 */
async function init() {
  if (!stage || !cardsRoot) return;
  // Preload images for faster loading
  preloadImageLinks(IMAGES);
  
  // Create DOM elements
  createCards();
  measure();

  // If the track is too short, wrapping becomes visible (a blurred edge card can
  // appear to "disappear" when it wraps). Repeat cards to push wrap off-screen.
  const minTrack = (window.innerWidth + STEP * 4);
  const minCount = Math.min(48, Math.max(IMAGES.length, Math.ceil(minTrack / STEP)));
  if (items.length < minCount) {
    createCards(minCount);
    measure();
  }
  updateCarouselTransforms();
  stage.classList.add('carousel-mode');

  // Wait for all images to load
  await waitForImages();

  // Decode images to prevent jank
  await decodeAllImages();

  // Force browser to paint images
  items.forEach((it) => {
    const img = it.el.querySelector('img');
    if (img) void img.offsetHeight;
  });

  // Find initial centered card
  const half = TRACK / 2;
  let closestIdx = 0;
  let closestDist = Infinity;

  for (let i = 0; i < items.length; i++) {
    let pos = items[i].x - SCROLL_X;
    if (pos < -half) pos += TRACK;
    if (pos > half) pos -= TRACK;
    const d = Math.abs(pos);
    if (d < closestDist) {
      closestDist = d;
      closestIdx = i;
    }
  }

  activeIndex = closestIdx;

  // Warmup GPU compositing
  await warmupCompositing();

  // Wait for browser idle time
  if ('requestIdleCallback' in window) {
    await new Promise((r) => requestIdleCallback(r, { timeout: 100 }));
  }

  // Prepare entry animation for visible cards
  const viewportWidth = window.innerWidth;
  const visibleCards = [];
  
  for (let i = 0; i < items.length; i++) {
    let pos = items[i].x - SCROLL_X;
    if (pos < -half) pos += TRACK;
    if (pos > half) pos -= TRACK;

    const screenX = pos;
    if (Math.abs(screenX) < viewportWidth * 0.6) {
      visibleCards.push({ item: items[i], screenX, index: i });
    }
  }

  // Sort cards left to right
  visibleCards.sort((a, b) => a.screenX - b.screenX);

  // Hide loader
  if (loader) loader.classList.add('loader--hide');

  // Animate cards entering
  await animateEntry(visibleCards);

  // Enable user interaction
  isEntering = false;

  // Start main carousel loop
  startCarousel();

  // Start autoplay
  startAutoAdvance();
}

// ============================================================================
// START APPLICATION
// ============================================================================

init();
</script>




<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

<script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
            }
        }
    </script>

<!-- GSAP Scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>


<script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- 1. Inject CSS ---
        const injectedStyles = `
            #animation-container-main {
                position: relative;
                width: 100%;
                background-color: transparent;
                color: white;
                z-index: 2;
                margin-top: 0;
            }
            #threejs-viewport {
                display: block;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100vh;
                z-index: 1;
                outline: none;
                pointer-events: none;
            }
            .scrollable-sections {
                position: relative;
                z-index: 3;
                margin-top: 0;
            }
            .content-panel {
                min-height: 100vh;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: flex-end;
                font-size: 4rem;
                pointer-events: none;
                width: 100%;
                margin: 0 auto;
                padding-left: 5vw;
                padding-right: 5vw;
                padding-bottom: 10vh;
                box-sizing: border-box;
                text-align: center;
                overflow-wrap: break-word;
                color: #000;
                text-shadow: 0 0 10px #fff;
            }

            .content-panel h1 {font-family:"Heading"; margin: 0; font-weight: 800; letter-spacing: -2px; color:var(--color); font-size:5rem}
            .content-panel p { font-family:"base"; font-size: 1.5rem; opacity: 0.7; font-weight: 300; margin-top: 10px; }
            .primary-label { color: #000; font-family:"Heading"; }
            .secondary-label { color: #000; font-family:"Heading"; }
        `;
        const dynamicStyleElement = document.createElement("style");
        dynamicStyleElement.innerText = injectedStyles;
        document.head.appendChild(dynamicStyleElement);

        // --- 2. Generate HTML Structure ---
        let mainContainer = document.getElementById('animation-container-main');
        if (!mainContainer) {
            mainContainer = document.createElement('div');
            mainContainer.id = 'animation-container-main';
            document.body.prepend(mainContainer);
        }
        
        mainContainer.innerHTML = `
            <canvas id="threejs-viewport"></canvas>
            <div class="scrollable-sections">
                <div class="content-panel">
                    <!-- Empty: Model rises up here -->
                </div>
                <div class="content-panel">
                    <h1>SPRAYZET</h1>
                    <p>Industrial MRO<span class="primary-label"> Aerosols</span></p>
                </div>
                <div class="content-panel">
                    <h1>Engineered to Perform.</h1>
                    <p>Built to Endure.</p>
                </div>
                <div class="content-panel">
                    <h1>The Transformation</h1>
                    <p>Watch the shift</p>
                </div>
                <div class="content-panel">
                    <h1>EVERSHINE</h1>
                    <p>Car Care <span class="secondary-label">Products</span></p>
                </div>
                <div class="content-panel">
                    <h1>Shine That You</h1>
                    <p>Can Feel.</p>
                </div>
                <div class="content-panel">
                    <h1>Next Chapter</h1>
                    <p>Unveiling strength</p>
                </div>
                <div class="content-panel">
                    <h1>TWIN TAPE</h1>
                    <p>Industrial <span class="primary-label">Adhesive Solutions</span></p>
                </div>
                <div class="content-panel">
                    <h1>Bonds That Last.</h1>
                    <p>Trust That Holds.</p>
                </div>
                <div class="content-panel">
                    <h1>Three Brands.</h1>
                    <p>One Vision of Excellence.</p>
                </div>
            </div>
        `;

        // --- 3. Initialize 3D & Animation ---
        gsap.registerPlugin(ScrollTrigger);

        const renderCanvas = document.querySelector('#threejs-viewport');
        
        // --- Scene Setup ---
        const threeScene = new THREE.Scene();
        
        const perspectiveCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        perspectiveCamera.position.set(0, 0, 5);

        const webglRenderer = new THREE.WebGLRenderer({ 
            canvas: renderCanvas,
            antialias: true, 
            alpha: true 
        });
        webglRenderer.setSize(window.innerWidth, window.innerHeight);
        webglRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        webglRenderer.shadowMap.enabled = true;
        webglRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
        webglRenderer.toneMapping = THREE.ACESFilmicToneMapping;
        webglRenderer.toneMappingExposure = 1.2;

        // --- Lighting ---
        const globalLight = new THREE.AmbientLight(0xffffff, 0.4);
        threeScene.add(globalLight);

        const primarySpotLight = new THREE.SpotLight(0xffffff, 20);
        primarySpotLight.position.set(5, 10, 7);
        primarySpotLight.angle = Math.PI / 4;
        primarySpotLight.penumbra = 0.3;
        primarySpotLight.castShadow = true;
        threeScene.add(primarySpotLight);

        const accentPointLight = new THREE.PointLight(0xffffff, 5);
        accentPointLight.position.set(-5, 0, 5);
        threeScene.add(accentPointLight);
        
        const backRimLight = new THREE.SpotLight(0xffffff, 10);
        backRimLight.position.set(0, 5, -5);
        backRimLight.lookAt(0, 0, 0);
        threeScene.add(backRimLight);

        // --- Model Loading ---
        const gltfModelLoader = new GLTFLoader();
        let firstModel, secondModel, tapeModel;
        const objectGroup = new THREE.Group();
        threeScene.add(objectGroup);

        const loadGltfAsset = (assetPath) => {
            return new Promise((resolve, reject) => {
                gltfModelLoader.load(assetPath, (gltfData) => {
                    const loadedModel = gltfData.scene;
                    loadedModel.traverse((meshNode) => {
                        if (meshNode.isMesh) {
                            meshNode.castShadow = true;
                            meshNode.receiveShadow = true;
                            if(meshNode.material) {
                                meshNode.material.envMapIntensity = 1.5;
                                meshNode.material.roughness = 0.2;
                                meshNode.material.metalness = 0.8;
                            }
                        }
                    });
                    const boundingBox = new THREE.Box3().setFromObject(loadedModel);
                    const dimensions = boundingBox.getSize(new THREE.Vector3());
                    const largestDimension = Math.max(dimensions.x, dimensions.y, dimensions.z);
                    const normalizedScale = 2.5 / largestDimension; 
                    loadedModel.scale.set(normalizedScale, normalizedScale, normalizedScale);
                    const centerPoint = boundingBox.getCenter(new THREE.Vector3());
                    loadedModel.position.sub(centerPoint.multiplyScalar(normalizedScale));
                    resolve(loadedModel);
                }, undefined, reject);
            });
        };

        // If running from file:// protocol the browser will often block GLTF asset loads
        // due to CORS. In that case, create fallback geometry immediately to avoid errors.
        const isFileProtocol = window.location.protocol === 'file:';
        if (isFileProtocol) {
            firstModel = generateFallbackGeometry(0xff3333);
            secondModel = generateFallbackGeometry(0x3388ff);
            tapeModel = generateFallbackTape(0x996633);

            objectGroup.add(firstModel);
            objectGroup.add(secondModel);
            threeScene.add(tapeModel);

            secondModel.visible = false;
            secondModel.rotation.copy(firstModel.rotation);

            // Initial State: Hidden below
            objectGroup.position.y = -10;
            objectGroup.rotation.y = Math.PI;

            // tape initial off-screen left
            tapeModel.position.set(-6, -1.5, 0);
            tapeModel.rotation.z = 0;

            initializeScrollAnimation();
        } else {
            Promise.all([
                loadGltfAsset('./assets/Black_Can.glb').catch(() => generateFallbackGeometry(0xff3333)),
                loadGltfAsset('./assets/Red_Can.glb').catch(() => generateFallbackGeometry(0x3388ff)),
                loadGltfAsset('./assets/Brown_Tape.glb').catch(() => generateFallbackTape(0x996633))
            ]).then(([primaryAsset, secondaryAsset, loadedTape]) => {
                firstModel = primaryAsset;
                secondModel = secondaryAsset;
                tapeModel = loadedTape;

                objectGroup.add(firstModel);
                objectGroup.add(secondModel);
                threeScene.add(tapeModel);

                secondModel.visible = false;
                secondModel.rotation.copy(firstModel.rotation);

                // Initial State: Hidden below
                objectGroup.position.y = -10; 
                objectGroup.rotation.y = Math.PI;

                // tape initial off-screen left
                tapeModel.position.set(-6, -1.5, 0);
                tapeModel.rotation.z = 0;

                initializeScrollAnimation();
            });
        }

        function generateFallbackGeometry(colorHex) {
            const cylinderGeometry = new THREE.CylinderGeometry(0.8, 0.8, 2.5, 32);
            const standardMaterial = new THREE.MeshStandardMaterial({ color: colorHex, metalness: 0.5, roughness: 0.2 });
            const fallbackMesh = new THREE.Mesh(cylinderGeometry, standardMaterial);
            return fallbackMesh;
        }

        function generateFallbackTape(colorHex) {
            // a flattened cylinder to simulate a tape roll
            const geo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 32);
            const mat = new THREE.MeshStandardMaterial({ color: colorHex, metalness: 0.3, roughness: 0.4 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = Math.PI / 2; // lie it on its side
            return mesh;
        }

        // --- Animation Logic ---
        function initializeScrollAnimation() {
            // Pin each text panel for snappy scroll behavior
            const panels = document.querySelectorAll('.content-panel');
            panels.forEach((panel, index) => {
                ScrollTrigger.create({
                    trigger: panel,
                    start: 'top top',
                    end: '+=200vh',
                    pin: true,
                    pinSpacing: true,
                    anticipatePin: 1
                });
            });

            // We use the wrapper as the trigger
            const animationTimeline = gsap.timeline({
                scrollTrigger: {
                    trigger: "#animation-container-main",
                    start: "top top",
                    end: "bottom bottom",
                    scrub: 1.5,
                }
            });

            // 0. REVEAL (First Section)
            // Dramatic rise with a slight tilt
            animationTimeline.to(objectGroup.position, {
                y: 0,
                duration: 1,
                ease: "power3.out"
            });
            
            animationTimeline.to(objectGroup.rotation, {
                y: 0,
                z: 0.1,
                duration: 1,
                ease: "power3.out"
            }, "<");

            // 1. Intro & Tilt
            animationTimeline.to(objectGroup.rotation, {
                y: Math.PI * 2,
                x: -0.2,
                z: 0,
                duration: 1,
                ease: "sine.inOut"
            });

            // 2. Cinematic Move
            animationTimeline.to(perspectiveCamera.position, {
                z: 3,
                y: 0.2,
                duration: 1,
                ease: "power2.inOut"
            }, "cinematic");
            
            animationTimeline.to(objectGroup.rotation, {
                z: -0.3,
                y: Math.PI * 4,
                duration: 1,
                ease: "power2.inOut"
            }, "cinematic");

            // 3. THE TRANSITION
            // Wind up
            animationTimeline.to(objectGroup.rotation, {
                y: Math.PI * 4,
                duration: 1,
                ease: "power2.in" 
            }, "swapStart");

            // Fast Spin
            animationTimeline.to(objectGroup.rotation, {
                y: Math.PI * 8,
                duration: 3,
                ease: "power2.inOut",
                onUpdate: function() {
                    const animProgress = this.progress();
                    if (animProgress > 0.5 && firstModel.visible) {
                        firstModel.visible = false;
                        secondModel.visible = true;
                    } else if (animProgress < 0.5 && !firstModel.visible) {
                        firstModel.visible = true;
                        secondModel.visible = false;
                    }
                }
            }, "swapSpin");

            // Camera shake/pull
            animationTimeline.to(perspectiveCamera.position, {
                z: 6.5,
                duration: 1.5,
                yoyo: true,
                repeat: 1,
                ease: "power2.inOut"
            }, "swapSpin");

            // 4. Settle
            animationTimeline.to(objectGroup.rotation, {
                y: Math.PI *10,
                x: 0,
                z: 0,
                duration: 1,
                ease: "power3.out"
            }, "settle");

            animationTimeline.to(perspectiveCamera.position, {
                z: 4,
                y: 0,
                duration: 1,
                ease: "power3.out"
            }, "settle");

            // 5. Final Presentation - Red can moves to right
            animationTimeline.to(objectGroup.position, {
                x: 2,
                y: 0,
                duration: 1,
                ease: "sine.inOut"
            }, "final");
            
            animationTimeline.to(objectGroup.rotation, {
                y: Math.PI * 12,
                duration: 1,
                ease: "sine.inOut"
            }, "final");

            // 6. Red can rolls out of the screen
            animationTimeline.to(objectGroup.position, {
                x: 7,
                duration: 1.5,
                ease: "power2.in"
            }, "canExit");

            animationTimeline.to(objectGroup.rotation, {
                y: Math.PI * 16,
                duration: 1.5,
                ease: "linear"
            }, "canExit");

            // TAPE ANIMATION: After red can exits, tape rolls in, zooms, then rolls out
            if (typeof tapeModel !== 'undefined' && tapeModel) {
                // Initial state: tape off-screen to the left
                tapeModel.position.set(-8, 0, 0);
                tapeModel.rotation.set(0, 0, 0);

                // 1. Tape rolls in from left to center (smooth rolling motion on z-axis)
                animationTimeline.to(tapeModel.position, {
                    x: 0,
                    y: -0.5,
                    z: 0,
                    duration: 1.5,
                    ease: 'power2.out'
                }, "tapeRollIn");

                animationTimeline.to(tapeModel.rotation, {
                    y: Math.PI * 3.8,
                    x:0.5,
                    duration: 1.5,
                    ease: 'none'
                }, "tapeRollIn");

                // 2. Tape zooms in (comes closer) with gentle rotation
                animationTimeline.to(tapeModel.position, {
                    z: 1,
                    duration: 1.2,
                    ease: 'power2.inOut'
                }, "tapeZoom");

                animationTimeline.to(tapeModel.rotation, {
                    y: Math.PI * 5.2,
                    duration: 1.2,
                    ease: 'sine.inOut'
                }, "tapeZoom");

                // 3. Tape rolls out to the right side of screen
                animationTimeline.to(tapeModel.position, {
                    x: 8,
                    y:0,
                    z: 0,
                    duration: 1.5,
                    ease: 'power2.in'
                }, "tapeRollOut");

                animationTimeline.to(tapeModel.rotation, {
                    y: Math.PI * 8,
                    duration: 1.5,
                    ease: 'none'
                }, "tapeRollOut");
            }
        }

        // --- Resize ---
        window.addEventListener('resize', () => {
            perspectiveCamera.aspect = window.innerWidth / window.innerHeight;
            perspectiveCamera.updateProjectionMatrix();
            webglRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Loop ---
        function renderLoop() {
            requestAnimationFrame(renderLoop);
            webglRenderer.render(threeScene, perspectiveCamera);
        }
        renderLoop();
    </script>

        <!-- Background Shader Script for 3D Animation Section -->
        <script type="module">
            import * as THREE from 'three';

            const container = document.getElementById('animationBgContainer');
            if (!container) {
                console.error('animationBgContainer not found - background shader will not initialize.');
            } else {

            const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(-1.1, 1.1, 1.1, -1.1, 0.1, 10);
            camera.position.z = 1;

            const renderer = new THREE.WebGLRenderer({
                antialias: false,
                stencil: false,
                depth: false,
                powerPreference: 'high-performance',
                alpha: true,
            });

            // initial size
            const w0 = container.clientWidth || window.innerWidth;
            const h0 = container.clientHeight || window.innerHeight;
            renderer.setSize(w0, h0);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.5));
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.width = '100%';
            renderer.domElement.style.height = '100%';
            renderer.domElement.style.pointerEvents = 'none';

            container.appendChild(renderer.domElement);

            const uniforms = {
                uTime: { value: 0.0 },
                uResolution: { value: new THREE.Vector2(w0, h0) },
                uMouse: { value: new THREE.Vector2(0.5, 1) }, // Fixed point (60% from left, 40% from top)
            };

            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const fragmentShader = `
                uniform float uTime;
                uniform vec2 uResolution;
                uniform vec2 uMouse;
                varying vec2 vUv;

                #define PI 3.14159265359

                float hash12(vec2 p) {
                    vec3 p3  = fract(vec3(p.xyx) * .2031);
                    p3 += dot(p3, p3.yzx + 38.33);
                    return fract((p3.x + p3.y) * p3.z);
                }

                float noise(vec2 p) {
                    return hash12(p);
                }

                vec2 rotate(vec2 uv, float angle) {
                    float s = sin(angle);
                    float c = cos(angle);
                    return vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
                }

                void main() {
                    vec2 uv = vUv - 0.5;
                    float aspect = uResolution.x / uResolution.y;
                    uv.x *= aspect;

                    vec2 mouse = uMouse - 0.5;
                    mouse.x *= aspect;

                    vec2 rotUv = rotate(uv, -PI / 4.0);

                    float frequency = 12.0;
                    float scroll = uTime * 0.001;
                    float t = fract(rotUv.y * frequency + scroll);

                    float sharpRise = pow(t, 0.001);
                    float sharpFall = pow(1.0 - t, 1.0);
                    float beams = smoothstep(0.01, 1.0, sharpRise * sharpFall);

                    float dist = distance(uv, mouse);
                    float spotLight = smoothstep(1.0, 0.0, dist);

                    float brightness = pow(beams * spotLight, 1.6);

                    // --- COLOR CHANGES HERE ---
                    vec3 backgroundColor = vec3(1.0, 1.0, 1.0);
                    vec3 crimson = vec3(0.7, 0.0, 0.0);
                    vec3 hotCore = vec3(1.0, 0.0, 0.0);

                    vec3 finalColor = mix(backgroundColor, crimson, smoothstep(0.0, 0.5, brightness));
                    finalColor = mix(finalColor, hotCore, smoothstep(0.5, 1.0, brightness));

                    float filmGrain = noise(gl_FragCoord.xy * 0.01 + uTime * 5.0);
                    float grainStrength = 0.3 * brightness * (1.0 - brightness * 0.7);
                    finalColor += (filmGrain - 0.5) * grainStrength;

                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;

            const material = new THREE.ShaderMaterial({
                uniforms,
                vertexShader,
                fragmentShader,
                depthTest: false,
                depthWrite: false,
            });

            const plane = new THREE.Mesh(new THREE.PlaneGeometry(4, 4), material);
            scene.add(plane);

            const onResize = () => {
                const w = container.clientWidth || window.innerWidth;
                const h = container.clientHeight || window.innerHeight;
                renderer.setSize(w, h);
                uniforms.uResolution.value.set(w, h);
            };

            window.addEventListener('resize', onResize);

            onResize();

            function animate() {
                requestAnimationFrame(animate);
                uniforms.uTime.value += 0.01;
                renderer.render(scene, camera);
            }

            animate();
                        }
        </script>

        <!-- Hero Section Background Shader Script -->
        <script type="module">
            import * as THREE from 'three';

            const heroContainer = document.getElementById('heroBgContainer');
            if (!heroContainer) {
                console.error('heroBgContainer not found');
            } else {

            const heroScene = new THREE.Scene();
            const heroCamera = new THREE.OrthographicCamera(-1.1, 1.1, 1.1, -1.1, 0.1, 10);
            heroCamera.position.z = 1;

            const heroRenderer = new THREE.WebGLRenderer({
                antialias: false,
                stencil: false,
                depth: false,
                powerPreference: 'high-performance',
                alpha: true,
            });

            const w0 = heroContainer.clientWidth || window.innerWidth;
            const h0 = heroContainer.clientHeight || window.innerHeight;
            heroRenderer.setSize(w0, h0);
            heroRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.5));
            heroRenderer.domElement.style.position = 'absolute';
            heroRenderer.domElement.style.top = '0';
            heroRenderer.domElement.style.left = '0';
            heroRenderer.domElement.style.width = '100%';
            heroRenderer.domElement.style.height = '100%';
            heroRenderer.domElement.style.pointerEvents = 'none';

            heroContainer.appendChild(heroRenderer.domElement);

            const heroUniforms = {
                uTime: { value: 0.0 },
                uResolution: { value: new THREE.Vector2(w0, h0) },
                uMouse: { value: new THREE.Vector2(0.5, 0.5) },
            };

            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const fragmentShader = `
                uniform float uTime;
                uniform vec2 uResolution;
                uniform vec2 uMouse;
                varying vec2 vUv;

                #define PI 3.14159265359

                float hash12(vec2 p) {
                    vec3 p3  = fract(vec3(p.xyx) * .2031);
                    p3 += dot(p3, p3.yzx + 38.33);
                    return fract((p3.x + p3.y) * p3.z);
                }

                float noise(vec2 p) {
                    return hash12(p);
                }

                vec2 rotate(vec2 uv, float angle) {
                    float s = sin(angle);
                    float c = cos(angle);
                    return vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
                }

                void main() {
                    vec2 uv = vUv - 0.5;
                    float aspect = uResolution.x / uResolution.y;
                    uv.x *= aspect;

                    vec2 mouse = uMouse - 0.5;
                    mouse.x *= aspect;

                    vec2 rotUv = rotate(uv, -PI / 4.0);

                    float frequency = 12.0;
                    float scroll = uTime * 0.001;
                    float t = fract(rotUv.y * frequency + scroll);

                    float sharpRise = pow(t, 0.001);
                    float sharpFall = pow(1.0 - t, 1.0);
                    float beams = smoothstep(0.01, 1.0, sharpRise * sharpFall);

                    float dist = distance(uv, mouse);
                    float spotLight = smoothstep(1.0, 0.0, dist);

                    float brightness = pow(beams * spotLight, 1.6);

                    vec3 backgroundColor = vec3(1.0, 1.0, 1.0);
                    vec3 crimson = vec3(0.7, 0.0, 0.0);
                    vec3 hotCore = vec3(1.0, 0.0, 0.0);

                    vec3 finalColor = mix(backgroundColor, crimson, smoothstep(0.0, 0.5, brightness));
                    finalColor = mix(finalColor, hotCore, smoothstep(0.5, 1.0, brightness));

                    float filmGrain = noise(gl_FragCoord.xy * 0.01 + uTime * 5.0);
                    float grainStrength = 0.3 * brightness * (1.0 - brightness * 0.7);
                    finalColor += (filmGrain - 0.5) * grainStrength;

                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;

            const heroMaterial = new THREE.ShaderMaterial({
                uniforms: heroUniforms,
                vertexShader,
                fragmentShader,
                depthTest: false,
                depthWrite: false,
            });

            const heroPlane = new THREE.Mesh(new THREE.PlaneGeometry(4, 4), heroMaterial);
            heroScene.add(heroPlane);

            const onHeroResize = () => {
                const w = heroContainer.clientWidth || window.innerWidth;
                const h = heroContainer.clientHeight || window.innerHeight;
                heroRenderer.setSize(w, h);
                heroUniforms.uResolution.value.set(w, h);
            };

            const onHeroMouseMove = (e) => {
                const rect = heroContainer.getBoundingClientRect();
                const nx = (e.clientX - rect.left) / rect.width;
                const ny = (e.clientY - rect.top) / rect.height;
                heroUniforms.uMouse.value.x = nx;
                heroUniforms.uMouse.value.y = 0.6 - ny;
            };

            window.addEventListener('resize', onHeroResize);
            window.addEventListener('mousemove', onHeroMouseMove);

            onHeroResize();

            function animateHero() {
                requestAnimationFrame(animateHero);
                heroUniforms.uTime.value += 0.01;
                heroRenderer.render(heroScene, heroCamera);
            }

            animateHero();
            }
        </script>
</body>
</html>