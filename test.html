<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
    <style>
        /* Ensure the main display and background canvas fill the viewport but allow scrolling */
        html,body{ overflow-x:hidden; }
        .main-display-area{ position:relative; width:100%; min-height:100vh; overflow:visible; }
        .background-canvas-holder{ position:fixed; top:0; left:0; width:100%; height:100vh; z-index:0; pointer-events:auto; }
        #animation-container-main{ position:relative; z-index:2; }
        /* Make sure the shader canvas covers its container */
        .background-canvas-holder canvas{ width:100% !important; height:100% !important; display:block; }
    </style>
</head>
<body>


<div class="main-display-area">
    <div id="heroBgContainer" class="background-canvas-holder"></div>
    <div id="animation-container-main"></div>
</div>





<script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>

<script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/"
            }
        }
    </script>

<!-- GSAP Scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/ScrollTrigger.min.js"></script>


<script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        // --- 1. Inject CSS ---
        const injectedStyles = `
            #animation-container-main {
                position: relative; /* Changed from absolute to relative to flow with document */
                width: 100%;
                background-color: transparent; /* Transparent to show heroBgContainer */
                color: white;
                z-index: 2; /* Above background */
                margin-top: 0;
            }
            #threejs-viewport {
                display: block;
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100vh;
                z-index: 1;
                outline: none;
                pointer-events: none; /* Let clicks pass through to background if needed */
            }
            .scrollable-sections {
                position: relative;
                z-index: 3;
                margin-top: 0;
            }
            .content-panel {
                height: 100vh;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                font-size: 4rem;
                text-shadow: 0 2px 10px rgba(0,0,0,0.8);
                pointer-events: none;
                width: 100%;
                margin: 0 auto;
                padding: 0 5vw;
                box-sizing: border-box;
                text-align: center;
                overflow-wrap: break-word;
            }

            .content-panel h1 {font-family:"Heading"; margin: 0; font-weight: 800; letter-spacing: -2px; color:#fff;}
            .content-panel p { font-family:"Regular"; font-size: 1.5rem; opacity: 0.7; font-weight: 300; margin-top: 10px; }
            .primary-label { color: #FFF; font-family:"Heading"; }
            .secondary-label { color: #FFF; font-family:"Heading"; }
        `;
        const dynamicStyleElement = document.createElement("style");
        dynamicStyleElement.innerText = injectedStyles;
        document.head.appendChild(dynamicStyleElement);

        // --- 2. Generate HTML Structure ---
        let mainContainer = document.getElementById('animation-container-main');
        if (!mainContainer) {
            mainContainer = document.createElement('div');
            mainContainer.id = 'animation-container-main';
            document.body.prepend(mainContainer);
        }
        
        mainContainer.innerHTML = `
            <canvas id="threejs-viewport"></canvas>
            <div class="scrollable-sections">
                <div class="content-panel">
                    <!-- Empty: Model rises up here -->
                </div>
                <div class="content-panel">
                    <h1>SPRAYZET</h1>
                    <p>Industrial MRO<span class="primary-label">Aerosols</span></p>
                </div>
                <div class="content-panel">
                    <h1>Engineered to Perform.</h1>
                    <p>Built to Endure.</p>
                </div>
                <div class="content-panel">
                    <h1>The Transformation</h1>
                    <p>Watch the shift</p>
                </div>
                <div class="content-panel">
                    <h1>EVERSHINE</h1>
                    <p>Car Care <span class="secondary-label">Products</span></p>
                </div>
                <div class="content-panel">
                    <h1>Shine That You</h1>
                    <p>Can Feel.</p>
                </div>
                <div class="content-panel">
                    <h1>Reflects Excellence.</h1>
                </div>
            </div>
        `;

        // --- 3. Initialize 3D & Animation ---
        gsap.registerPlugin(ScrollTrigger);

        const renderCanvas = document.querySelector('#threejs-viewport');
        
        // --- Scene Setup ---
        const threeScene = new THREE.Scene();
        
        const perspectiveCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
        perspectiveCamera.position.set(0, 0, 5);

        const webglRenderer = new THREE.WebGLRenderer({ 
            canvas: renderCanvas,
            antialias: true, 
            alpha: true 
        });
        webglRenderer.setSize(window.innerWidth, window.innerHeight);
        webglRenderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        webglRenderer.shadowMap.enabled = true;
        webglRenderer.shadowMap.type = THREE.PCFSoftShadowMap;
        webglRenderer.toneMapping = THREE.ACESFilmicToneMapping;
        webglRenderer.toneMappingExposure = 1.2;

        // --- Lighting ---
        const globalLight = new THREE.AmbientLight(0xffffff, 0.4);
        threeScene.add(globalLight);

        const primarySpotLight = new THREE.SpotLight(0xffffff, 20);
        primarySpotLight.position.set(5, 10, 7);
        primarySpotLight.angle = Math.PI / 4;
        primarySpotLight.penumbra = 0.3;
        primarySpotLight.castShadow = true;
        threeScene.add(primarySpotLight);

        const accentPointLight = new THREE.PointLight(0xff9000, 5);
        accentPointLight.position.set(-5, 0, 5);
        threeScene.add(accentPointLight);
        
        const backRimLight = new THREE.SpotLight(0x0044ff, 10);
        backRimLight.position.set(0, 5, -5);
        backRimLight.lookAt(0, 0, 0);
        threeScene.add(backRimLight);

        // --- Model Loading ---
        const gltfModelLoader = new GLTFLoader();
        let firstModel, secondModel, tapeModel;
        const objectGroup = new THREE.Group();
        threeScene.add(objectGroup);

        const loadGltfAsset = (assetPath) => {
            return new Promise((resolve, reject) => {
                gltfModelLoader.load(assetPath, (gltfData) => {
                    const loadedModel = gltfData.scene;
                    loadedModel.traverse((meshNode) => {
                        if (meshNode.isMesh) {
                            meshNode.castShadow = true;
                            meshNode.receiveShadow = true;
                            if(meshNode.material) {
                                meshNode.material.envMapIntensity = 1.5;
                                meshNode.material.roughness = 0.2;
                                meshNode.material.metalness = 0.8;
                            }
                        }
                    });
                    const boundingBox = new THREE.Box3().setFromObject(loadedModel);
                    const dimensions = boundingBox.getSize(new THREE.Vector3());
                    const largestDimension = Math.max(dimensions.x, dimensions.y, dimensions.z);
                    const normalizedScale = 2.5 / largestDimension; 
                    loadedModel.scale.set(normalizedScale, normalizedScale, normalizedScale);
                    const centerPoint = boundingBox.getCenter(new THREE.Vector3());
                    loadedModel.position.sub(centerPoint.multiplyScalar(normalizedScale));
                    resolve(loadedModel);
                }, undefined, reject);
            });
        };

        // If running from file:// protocol the browser will often block GLTF asset loads
        // due to CORS. In that case, create fallback geometry immediately to avoid errors.
        const isFileProtocol = window.location.protocol === 'file:';
        if (isFileProtocol) {
            firstModel = generateFallbackGeometry(0xff3333);
            secondModel = generateFallbackGeometry(0x3388ff);
            tapeModel = generateFallbackTape(0x996633);

            objectGroup.add(firstModel);
            objectGroup.add(secondModel);
            threeScene.add(tapeModel);

            secondModel.visible = false;
            secondModel.rotation.copy(firstModel.rotation);

            // Initial State: Hidden below
            objectGroup.position.y = -10;
            objectGroup.rotation.y = Math.PI;

            // tape initial off-screen left
            tapeModel.position.set(-6, -1.5, 0);
            tapeModel.rotation.z = 0;

            initializeScrollAnimation();
        } else {
            Promise.all([
                loadGltfAsset('./assets/Black_Can.glb').catch(() => generateFallbackGeometry(0xff3333)),
                loadGltfAsset('./assets/Red_Can.glb').catch(() => generateFallbackGeometry(0x3388ff)),
                loadGltfAsset('./assets/Brown_Tape.glb').catch(() => generateFallbackTape(0x996633))
            ]).then(([primaryAsset, secondaryAsset, loadedTape]) => {
                firstModel = primaryAsset;
                secondModel = secondaryAsset;
                tapeModel = loadedTape;

                objectGroup.add(firstModel);
                objectGroup.add(secondModel);
                threeScene.add(tapeModel);

                secondModel.visible = false;
                secondModel.rotation.copy(firstModel.rotation);

                // Initial State: Hidden below
                objectGroup.position.y = -10; 
                objectGroup.rotation.y = Math.PI;

                // tape initial off-screen left
                tapeModel.position.set(-6, -1.5, 0);
                tapeModel.rotation.z = 0;

                initializeScrollAnimation();
            });
        }

        function generateFallbackGeometry(colorHex) {
            const cylinderGeometry = new THREE.CylinderGeometry(0.8, 0.8, 2.5, 32);
            const standardMaterial = new THREE.MeshStandardMaterial({ color: colorHex, metalness: 0.5, roughness: 0.2 });
            const fallbackMesh = new THREE.Mesh(cylinderGeometry, standardMaterial);
            return fallbackMesh;
        }

        function generateFallbackTape(colorHex) {
            // a flattened cylinder to simulate a tape roll
            const geo = new THREE.CylinderGeometry(0.6, 0.6, 0.4, 32);
            const mat = new THREE.MeshStandardMaterial({ color: colorHex, metalness: 0.3, roughness: 0.4 });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = Math.PI / 2; // lie it on its side
            return mesh;
        }

        // --- Animation Logic ---
        function initializeScrollAnimation() {
            // We use the wrapper as the trigger
            const animationTimeline = gsap.timeline({
                scrollTrigger: {
                    trigger: "#animation-container-main",
                    start: "top top",
                    end: "bottom bottom",
                    scrub: 1.5,
                }
            });

            // 0. REVEAL (First Section)
            // Dramatic rise with a slight tilt
            animationTimeline.to(objectGroup.position, {
                y: 0,
                duration: 1,
                ease: "power3.out"
            });
            
            animationTimeline.to(objectGroup.rotation, {
                y: 0,
                z: 0.1,
                duration: 1,
                ease: "power3.out"
            }, "<");

            // 1. Intro & Tilt
            animationTimeline.to(objectGroup.rotation, {
                y: Math.PI * 2,
                x: -0.2,
                z: 0,
                duration: 1,
                ease: "sine.inOut"
            });

            // 2. Cinematic Move
            animationTimeline.to(perspectiveCamera.position, {
                z: 3,
                y: 0.2,
                duration: 1,
                ease: "power2.inOut"
            }, "cinematic");
            
            animationTimeline.to(objectGroup.rotation, {
                z: -0.3,
                y: Math.PI * 4,
                duration: 1,
                ease: "power2.inOut"
            }, "cinematic");

            // 3. THE TRANSITION
            // Wind up
            animationTimeline.to(objectGroup.rotation, {
                y: Math.PI * 4,
                duration: 1,
                ease: "power2.in" 
            }, "swapStart");

            // Fast Spin
            animationTimeline.to(objectGroup.rotation, {
                y: Math.PI * 8,
                duration: 3,
                ease: "power2.inOut",
                onUpdate: function() {
                    const animProgress = this.progress();
                    if (animProgress > 0.5 && firstModel.visible) {
                        firstModel.visible = false;
                        secondModel.visible = true;
                    } else if (animProgress < 0.5 && !firstModel.visible) {
                        firstModel.visible = true;
                        secondModel.visible = false;
                    }
                }
            }, "swapSpin");

            // Camera shake/pull
            animationTimeline.to(perspectiveCamera.position, {
                z: 6.5,
                duration: 1.5,
                yoyo: true,
                repeat: 1,
                ease: "power2.inOut"
            }, "swapSpin");

            // 4. Settle
            animationTimeline.to(objectGroup.rotation, {
                y: Math.PI *10,
                x: 0,
                z: 0,
                duration: 1,
                ease: "power3.out"
            }, "settle");

            animationTimeline.to(perspectiveCamera.position, {
                z: 4,
                y: 0,
                duration: 1,
                ease: "power3.out"
            }, "settle");

            // 5. Final Presentation
            animationTimeline.to(objectGroup.position, {
                x: 2,
                y: 0,
                duration: 1,
                ease: "sine.inOut"
            }, "final");
            
            animationTimeline.to(objectGroup.rotation, {
                y: Math.PI * 12,
                duration: 1,
                ease: "sine.inOut"
            }, "final");

            // TAPE ANIMATION: roll in from left, cinematic reveal, roll out to right
            if (typeof tapeModel !== 'undefined' && tapeModel) {
                // ensure tape is above background but below UI
                tapeModel.position.y = -1.5;
                tapeModel.position.x = -6;
                tapeModel.rotation.z = 0;

                // create tape timeline tied to the same ScrollTrigger
                animationTimeline.to(tapeModel.position, {
                    x: -1.0,
                    duration: 1.2,
                    ease: 'power3.out'
                }, "tapeStart");

                // rolling while moving in
                animationTimeline.to(tapeModel.rotation, {
                    z: Math.PI * 4,
                    duration: 1.2,
                    ease: 'none'
                }, "tapeStart");

                // cinematic turn: rotate to reveal brand (rotate on Y)
                animationTimeline.to(tapeModel.rotation, {
                    y: Math.PI * 1.2,
                    duration: 1,
                    ease: 'power2.inOut'
                }, "cinematic+=0.3");

                // hold briefly then roll out to right
                animationTimeline.to(tapeModel.position, {
                    x: 6,
                    duration: 1.2,
                    ease: 'power3.in'
                }, "final+=0.2");

                animationTimeline.to(tapeModel.rotation, {
                    z: Math.PI * 8,
                    duration: 1.2,
                    ease: 'none'
                }, "final+=0.2");
            }
        }

        // --- Resize ---
        window.addEventListener('resize', () => {
            perspectiveCamera.aspect = window.innerWidth / window.innerHeight;
            perspectiveCamera.updateProjectionMatrix();
            webglRenderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- Loop ---
        function renderLoop() {
            requestAnimationFrame(renderLoop);
            webglRenderer.render(threeScene, perspectiveCamera);
        }
        renderLoop();
    </script>

        <!-- Background Shader Script -->
        <script type="module">
            import * as THREE from 'three';

            const container = document.getElementById('heroBgContainer');
            if (!container) {
                console.error('heroBgContainer not found - background shader will not initialize.');
            } else {

            const scene = new THREE.Scene();
            const camera = new THREE.OrthographicCamera(-1.1, 1.1, 1.1, -1.1, 0.1, 10);
            camera.position.z = 1;

            const renderer = new THREE.WebGLRenderer({
                antialias: false,
                stencil: false,
                depth: false,
                powerPreference: 'high-performance',
                alpha: true,
            });

            // initial size
            const w0 = container.clientWidth || window.innerWidth;
            const h0 = container.clientHeight || window.innerHeight;
            renderer.setSize(w0, h0);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.5));
            renderer.domElement.style.position = 'absolute';
            renderer.domElement.style.top = '0';
            renderer.domElement.style.left = '0';
            renderer.domElement.style.width = '100%';
            renderer.domElement.style.height = '100%';
            renderer.domElement.style.pointerEvents = 'none';

            container.appendChild(renderer.domElement);

            const uniforms = {
                uTime: { value: 0.0 },
                uResolution: { value: new THREE.Vector2(w0, h0) },
                uMouse: { value: new THREE.Vector2(0.5, 0.5) },
            };

            const vertexShader = `
                varying vec2 vUv;
                void main() {
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `;

            const fragmentShader = `
                uniform float uTime;
                uniform vec2 uResolution;
                uniform vec2 uMouse;
                varying vec2 vUv;

                #define PI 3.14159265359

                float hash12(vec2 p) {
                    vec3 p3  = fract(vec3(p.xyx) * .2031);
                    p3 += dot(p3, p3.yzx + 38.33);
                    return fract((p3.x + p3.y) * p3.z);
                }

                float noise(vec2 p) {
                    return hash12(p);
                }

                vec2 rotate(vec2 uv, float angle) {
                    float s = sin(angle);
                    float c = cos(angle);
                    return vec2(uv.x * c - uv.y * s, uv.x * s + uv.y * c);
                }

                void main() {
                    vec2 uv = vUv - 0.5;
                    float aspect = uResolution.x / uResolution.y;
                    uv.x *= aspect;

                    vec2 mouse = uMouse - 0.5;
                    mouse.x *= aspect;

                    vec2 rotUv = rotate(uv, -PI / 4.0);

                    float frequency = 12.0;
                    float scroll = uTime * 0.001;
                    float t = fract(rotUv.y * frequency + scroll);

                    float sharpRise = pow(t, 0.001);
                    float sharpFall = pow(1.0 - t, 1.0);
                    float beams = smoothstep(0.01, 1.0, sharpRise * sharpFall);

                    float dist = distance(uv, mouse);
                    float spotLight = smoothstep(1.0, 0.0, dist);

                    float brightness = pow(beams * spotLight, 1.6);

                    // --- COLOR CHANGES HERE ---
                    vec3 backgroundColor = vec3(1.0, 1.0, 1.0);
                    vec3 crimson = vec3(0.7, 0.0, 0.0);
                    vec3 hotCore = vec3(1.0, 0.0, 0.0);

                    vec3 finalColor = mix(backgroundColor, crimson, smoothstep(0.0, 0.5, brightness));
                    finalColor = mix(finalColor, hotCore, smoothstep(0.5, 1.0, brightness));

                    float filmGrain = noise(gl_FragCoord.xy * 0.01 + uTime * 5.0);
                    float grainStrength = 0.3 * brightness * (1.0 - brightness * 0.7);
                    finalColor += (filmGrain - 0.5) * grainStrength;

                    gl_FragColor = vec4(finalColor, 1.0);
                }
            `;

            const material = new THREE.ShaderMaterial({
                uniforms,
                vertexShader,
                fragmentShader,
                depthTest: false,
                depthWrite: false,
            });

            const plane = new THREE.Mesh(new THREE.PlaneGeometry(4, 4), material);
            scene.add(plane);

            const onResize = () => {
                const w = container.clientWidth || window.innerWidth;
                const h = container.clientHeight || window.innerHeight;
                renderer.setSize(w, h);
                uniforms.uResolution.value.set(w, h);
            };

            const onMouseMove = (e) => {
                const rect = container.getBoundingClientRect();
                const nx = (e.clientX - rect.left) / rect.width;
                const ny = (e.clientY - rect.top) / rect.height;
                uniforms.uMouse.value.x = nx;
                uniforms.uMouse.value.y = 0.6 - ny;
            };

            window.addEventListener('resize', onResize);
            // Listen on the window so mouse is captured even when other DOM layers are above
            window.addEventListener('mousemove', onMouseMove);

            onResize();

            function animate() {
                requestAnimationFrame(animate);
                uniforms.uTime.value += 0.01;
                renderer.render(scene, camera);
            }

            animate();
                        }
        </script>
</body>
</html>